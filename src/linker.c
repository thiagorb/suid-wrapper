#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <byteswap.h>
#include <sys/stat.h>
#include <argp.h>
#include <stdbool.h>
#include <fcntl.h>
#include "wrapper.h"

const char *argp_program_version = APP_NAME " " APP_VERSION;
const char *argp_program_bug_address = "<https://github.com/thiagorb/" APP_NAME ">";
static char doc[] = APP_NAME " is a program that creates an executable binary that executes another given binary with pre-configured arguments.";
static char args_doc[] = "<executable> [...args]";

static struct argp_option options[] = {
	{"inspect", 'i', "FILE", 0, "Inspect a binary generated by this program"},
	{"verbose", 'v', 0, 0, "Produce verbose output"},
	{"output", 'o', "FILE", 0, "Path to output binary"},
	{"force", 'f', 0, 0, "Overwrite output file if it already exists"},
	{"quiet", 'q', 0, 0, "Suppress all output"},
	{"allow-extra-args", 'e', 0, 0, "Allow extra arguments to be passed to the generated binary"},
	{0}
};

typedef enum
{
	inspect,
	link
} argument_mode;

struct arguments
{
	argument_mode mode;
	char *inspect;
	const char *output;
	int argc;
	char **argv;
	bool force;
	bool allow_extra_args;
};

static error_t parse_opt(int key, char *arg, struct argp_state *state)
{
	struct arguments * arguments = (struct arguments *)state->input;

	switch (key)
	{
	case 'i':
		arguments->mode = inspect;
		arguments->inspect = arg;
		break;

	case 'v':
		log_debug = log_stderr;
		break;

	case 'o':
		arguments->output = arg;
		break;

	case 'f':
		arguments->force = true;
		break;

	case 'e':
		arguments->allow_extra_args = true;
		break;

	case 'q':
		log_info = log_silent;
		log_error = log_silent;
		break;

	case ARGP_KEY_ARG:
		arguments->argv[arguments->argc++] = arg;
		break;

	case ARGP_KEY_END:
		if (arguments->argc < 1 && arguments->mode == link)
		{
			argp_usage(state);
		}
		break;

	default:
		return ARGP_ERR_UNKNOWN;
	}

	return 0;
}

static struct argp argp = {options, parse_opt, args_doc, doc};

const uint64_t BUFFER_SIZE = 1024 * 1024;

static int generate_binary(struct arguments arguments);
static wrapper *wrapper_build_from_args(struct arguments arguments);

extern char _binary_runner_start[];
extern char _binary_runner_end[];

int main(int argc, char **argv)
{
	struct arguments arguments;
	arguments.force = false;
	arguments.allow_extra_args = false;
	arguments.mode = link;
	arguments.inspect = NULL;
	arguments.output = "a.out";
	arguments.argc = 0;
	arguments.argv = (char **)malloc(sizeof(char *) * argc);
	if (arguments.argv == NULL)
	{
		log_error("Failed to allocate arguments argv!\n");
		return 1;
	}

  	argp_parse(&argp, argc, argv, 0, 0, &arguments);

	if (arguments.inspect)
	{
		log_info("Runner: %s\n", arguments.inspect);
		FILE *runner = open_exe(arguments.inspect);
		if (!runner)
		{
			log_error("Unable to open file at %s.\n", arguments.inspect);
			return 1;
		}

		wrapper *wrapper = wrapper_build_from_runner(runner);
		fclose(runner);
		if (wrapper == NULL)
		{
			return 1;
		}

		log_info("Arguments count: %i\n", wrapper->argc);
		for (size_t i = 0; i < wrapper->argc; i++)
		{
			log_info("Argument %li: %s\n", i, wrapper->argv[i]);
		}
		log_info("Allow extra arguments: %s\n", wrapper->allow_extra_args ? "yes" : "no");
		wrapper_destroy(wrapper);

		return 0;
	}

	return generate_binary(arguments);
}

static int generate_binary(struct arguments arguments)
{
	FILE *output = NULL;
	if (arguments.force)
	{
		output = fopen(arguments.output, "w");
	}
	else
	{
		int fd = open(arguments.output, O_CREAT | O_EXCL | O_RDWR, 06711);
		output = fdopen(fd, "w+");
	}

	if (!output)
	{
		if (arguments.force)
		{
			log_error("Unable to open output file for writing.\n");
		}
		else
		{
			log_error("Unable to open output file for writing (use --force to overwrite existing file).\n");
		}

		return 1;
	}

	uint32_t runner_size = _binary_runner_end - _binary_runner_start;
	log_debug("Size of runner without arguments: %i\n", runner_size);
	if (runner_size != fwrite(_binary_runner_start, sizeof(char), runner_size, output))
	{
		log_error("Failed to write to output file.\n");
		return 1;
	}

	wrapper *wrapper = wrapper_build_from_args(arguments);
	if (wrapper == NULL)
	{
		return 1;
	}
	char resolved_path[PATH_MAX];
    if (realpath(wrapper->argv[0], resolved_path) == NULL)
    {
        log_error("Unable to locate executable at \"%s\".\nPlease provide the absolute path to the binary.\n", wrapper->argv[0]);
        return 1;
    }

	char marker[] = APP_NAME;
	fwrite(marker, sizeof(marker), 1, output);
	version version = get_version();
	fwrite(&version, sizeof(version), 1, output);

	log_debug("Arguments count: %i\n", wrapper->argc);
	fwrite(&wrapper->argc, sizeof(wrapper->argc), 1, output);
	for (int i = 0; i < wrapper->argc; i++)
	{
		argv_len_t len = strlen(wrapper->argv[i]);
		log_debug("Argument %i: (len %i) ", i, len);
		log_debug("%s\n", wrapper->argv[i]);
		fwrite(&len, sizeof(len), 1, output);
		fwrite(wrapper->argv[i], 1, len, output);
	}
	fwrite(&wrapper->allow_extra_args, sizeof(wrapper->allow_extra_args), 1, output);
	wrapper_destroy(wrapper);

	fwrite(&runner_size, sizeof(runner_size), 1, output);

	fclose(output);
	chmod(arguments.output, 06711);

	return 0;
}

static wrapper *wrapper_build_from_args(struct arguments arguments)
{
    if (arguments.argc < 1)
    {
        log_error("Invalid arguments for wrapper_build_from_args");
        return NULL;
    }

	wrapper *result = wrapper_new(arguments.argc);
	if (result == NULL)
	{
		return NULL;
	}

    result->argv[0] = realpath(arguments.argv[0], NULL);
    if (result->argv[0] == NULL)
    {
        log_error("Failed to resolve path to \"%s\".\n", arguments.argv[0]);
        wrapper_destroy(result);
        return NULL;
    }

	for (int i = 1; i < result->argc; i++)
	{
		argv_len_t len = strlen(arguments.argv[i]);
		result->argv[i] = (char *)malloc(sizeof(char) * (len + 1));
		if (result->argv[i] == NULL)
		{
			log_error("Failed to allocate wrapper argv[%i] with length %i!\n", i, len);
			wrapper_destroy(result);
			return NULL;
		}
		strcpy(result->argv[i], arguments.argv[i]);
	}

	if (arguments.allow_extra_args)
	{
		result->allow_extra_args = true;
	}

	return result;
}
