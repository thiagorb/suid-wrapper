#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <byteswap.h>
#include <sys/stat.h>
#include <argp.h>
#include <stdbool.h>
#include <fcntl.h>
#include "wrapper.h"

#ifndef APP_NAME
	#define APP_NAME "suid-wrapper"
#endif

#ifndef APP_VERSION
	#define APP_VERSION "0.1"
#endif

const char *argp_program_version = APP_NAME " " APP_VERSION;
const char *argp_program_bug_address = "<https://github.com/thiagorb/" APP_NAME ">";
static char doc[] = APP_NAME " is a program that creates an executable binary that executes another given binary with pre-configured arguments.";
static char args_doc[] = "<executable> [...args]";

static struct argp_option options[] = {
	{"inspect", 'i', "FILE", 0, "Inspect a binary generated by this program"},
	{"verbose", 'v', 0, 0, "Produce verbose output"},
	{"output", 'o', "FILE", 0, "Path to output binary"},
	{"force", 'f', 0, 0, "Overwrite output file if it already exists"},
	{"quiet", 'q', 0, 0, "Suppress all output"},
	{0}
};

typedef enum
{
	inspect,
	link
} argument_mode;

struct arguments
{
	argument_mode mode;
	char *inspect;
	const char *output;
	int argc;
	char **argv;
	bool force;
};

static error_t parse_opt(int key, char *arg, struct argp_state *state)
{
	struct arguments * arguments = (struct arguments *)state->input;

	switch (key)
	{
	case 'i':
		arguments->mode = inspect;
		arguments->inspect = arg;
		break;

	case 'v':
		log_debug = log_stderr;
		break;

	case 'o':
		arguments->output = arg;
		break;

	case 'f':
		arguments->force = true;
		break;

	case 'q':
		log_info = log_silent;
		log_error = log_silent;
		break;

	case ARGP_KEY_ARG:
		arguments->argv[arguments->argc++] = arg;
		break;

	case ARGP_KEY_END:
		if (arguments->argc < 1 && arguments->mode == link)
		{
			argp_usage(state);
		}
		break;

	default:
		return ARGP_ERR_UNKNOWN;
	}

	return 0;
}

static struct argp argp = {options, parse_opt, args_doc, doc};

const uint64_t BUFFER_SIZE = 1024 * 1024;

int generate_binary(struct arguments arguments);

extern char _binary_runner_start[];
extern char _binary_runner_end[];

int main(int argc, char **argv)
{
	struct arguments arguments;
	arguments.force = false;
	arguments.mode = link;
	arguments.argc = 0;
	arguments.argv = (char **)malloc(sizeof(char *) * argc);
	arguments.inspect = NULL;
	arguments.output = "a.out";
	log_debug = log_silent;
	log_info = log_stderr;
	log_error = log_stderr;

  	argp_parse(&argp, argc, argv, 0, 0, &arguments);

	if (arguments.inspect)
	{
		log_info("Runner: %s\n", arguments.inspect);
		FILE *runner = open_exe(arguments.inspect);
		if (!runner)
		{
			log_error("Unable to open file at %s.\n", arguments.inspect);
			return 1;
		}

		wrapper *wrapper = wrapper_build_from_runner(runner);
		fclose(runner);
		log_info("Arguments count: %i\n", wrapper->argc);
		for (size_t i = 0; i < wrapper->argc; i++)
		{
			log_info("Argument %li: %s\n", i, wrapper->argv[i]);
		}
		wrapper_destroy(wrapper);

		return 1;
	}

	return generate_binary(arguments);
}

int generate_binary(struct arguments arguments)
{
	FILE *output = NULL;
	if (arguments.force)
	{
		output = fopen(arguments.output, "w");
	}
	else
	{
		int fd = open(arguments.output, O_CREAT | O_EXCL | O_RDWR, 06711);
		output = fdopen(fd, "w+");
	}

	if (!output)
	{
		if (arguments.force)
		{
			log_error("Unable to open output file for writing.\n");
		}
		else
		{
			log_error("Unable to open output file for writing (use --force to overwrite existing file).\n");
		}

		return 1;
	}

	uint32_t runner_size = _binary_runner_end - _binary_runner_start;
	log_debug("Size of runner without arguments: %i\n", runner_size);
	if (runner_size != fwrite(_binary_runner_start, sizeof(char), runner_size, output))
	{
		log_error("Failed to write to output file.\n");
		return 1;
	}

	wrapper *wrapper = wrapper_build_from_args(arguments.argc, arguments.argv);
	log_debug("Arguments count: %i\n", wrapper->argc);

	fwrite(&wrapper->argc, sizeof(wrapper->argc), 1, output);
	for (int i = 0; i < wrapper->argc; i++)
	{
		argv_len_t len = strlen(wrapper->argv[i]);
		log_debug("Argument %i: (len %i) ", i, len);
		log_debug("%s\n", wrapper->argv[i]);
		fwrite(&len, sizeof(len), 1, output);
		fwrite(wrapper->argv[i], 1, len, output);
	}
	wrapper_destroy(wrapper);

	fwrite(&runner_size, sizeof(runner_size), 1, output);

	fclose(output);
	chmod(arguments.output, 06711);

	return 0;
}
